{{#if has_database}}
{{#if has_postgresql}}
{{#if has_sqlite}}
use sqlx::{
    postgres::PgPoolOptions,
    sqlite::SqlitePoolOptions,
    Pool, Postgres, Sqlite,
};
use std::env;

/// Database connection (supports both PostgreSQL and SQLite)
pub enum DbPool {
    PostgreSQL(Pool<Postgres>),
    SQLite(Pool<Sqlite>),
}

impl DbPool {
    /// Create database pool from DATABASE_URL
    pub async fn from_env() -> anyhow::Result<Self> {
        let database_url = env::var("DATABASE_URL")
            .map_err(|_| anyhow::anyhow!("DATABASE_URL environment variable not set"))?;

        // Detect database type from URL scheme
        if database_url.starts_with("postgresql://") || database_url.starts_with("postgres://") {
            let pool = PgPoolOptions::new()
                .max_connections(10)
                .connect(&database_url)
                .await?;
            Ok(DbPool::PostgreSQL(pool))
        } else if database_url.starts_with("sqlite://") {
            let pool = SqlitePoolOptions::new()
                .max_connections(10)
                .connect(&database_url)
                .await?;
            Ok(DbPool::SQLite(pool))
        } else {
            Err(anyhow::anyhow!("Unsupported DATABASE_URL format. Must start with postgresql://, postgres://, or sqlite://"))
        }
    }

    /// Run migrations
    pub async fn run_migrations(&self) -> anyhow::Result<()> {
        match self {
            DbPool::PostgreSQL(pool) => {
                sqlx::migrate!("./migrations").run(pool).await?;
            }
            DbPool::SQLite(pool) => {
                sqlx::migrate!("./migrations").run(pool).await?;
            }
        }
        Ok(())
    }
}
{{else}}
use sqlx::{postgres::PgPoolOptions, Pool, Postgres};
use std::env;

/// PostgreSQL connection pool
pub type DbPool = Pool<Postgres>;

/// Create PostgreSQL pool from DATABASE_URL
pub async fn create_pool() -> anyhow::Result<DbPool> {
    let database_url = env::var("DATABASE_URL")
        .map_err(|_| anyhow::anyhow!("DATABASE_URL environment variable not set"))?;

    let pool = PgPoolOptions::new()
        .max_connections(10)
        .connect(&database_url)
        .await?;

    Ok(pool)
}

/// Run database migrations
pub async fn run_migrations(pool: &DbPool) -> anyhow::Result<()> {
    sqlx::migrate!("./migrations").run(pool).await?;
    Ok(())
}
{{/if}}
{{else}}
{{#if has_sqlite}}
use sqlx::{sqlite::SqlitePoolOptions, Pool, Sqlite};
use std::env;

/// SQLite connection pool
pub type DbPool = Pool<Sqlite>;

/// Create SQLite pool from DATABASE_URL
pub async fn create_pool() -> anyhow::Result<DbPool> {
    let database_url = env::var("DATABASE_URL")
        .map_err(|_| anyhow::anyhow!("DATABASE_URL environment variable not set"))?;

    let pool = SqlitePoolOptions::new()
        .max_connections(10)
        .connect(&database_url)
        .await?;

    Ok(pool)
}

/// Run database migrations
pub async fn run_migrations(pool: &DbPool) -> anyhow::Result<()> {
    sqlx::migrate!("./migrations").run(pool).await?;
    Ok(())
}
{{/if}}
{{/if}}
{{/if}}
