// Generation metadata management
//
// This module handles reading and writing `.axum-app-create.json` metadata files
// that track project generation configuration and file checksums.

use crate::config::ProjectConfig;
use crate::error::{CliError, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;

/// Metadata file name
pub const METADATA_FILE: &str = ".axum-app-create.json";

/// Generation metadata structure
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct GenerationMetadata {
    /// Tool version that generated the project
    pub version: String,
    /// ISO 8601 timestamp of generation
    pub generated_at: String,
    /// Full project configuration used for generation
    pub config: ProjectConfig,
    /// SHA-256 checksums for each generated file
    pub file_checksums: HashMap<String, String>,
}

/// Generation metadata manager
pub struct MetadataManager;

impl MetadataManager {
    /// Create metadata for a newly generated project
    pub fn create(
        project_dir: &Path,
        config: &ProjectConfig,
        file_checksums: HashMap<String, String>,
    ) -> Result<()> {
        let metadata = GenerationMetadata {
            version: env!("CARGO_PKG_VERSION").to_string(),
            generated_at: chrono::Utc::now().to_rfc3339(),
            config: config.clone(),
            file_checksums,
        };

        let json = serde_json::to_string_pretty(&metadata).map_err(|e| {
            CliError::Generation(format!(
                "âŒ å…ƒæ•°æ®åºåˆ—åŒ–å¤±è´¥ / Metadata serialization failed: {}",
                e
            ))
        })?;

        let metadata_path = project_dir.join(METADATA_FILE);
        std::fs::write(&metadata_path, &json)?;

        Ok(())
    }

    /// Read metadata from an existing project
    pub fn read(project_dir: &Path) -> Result<GenerationMetadata> {
        let metadata_path = project_dir.join(METADATA_FILE);

        if !metadata_path.exists() {
            return Err(CliError::Config(format!(
                "âŒ å…ƒæ•°æ®æ–‡ä»¶ä¸å­˜åœ¨ / Metadata file not found: '{}'\n\
                 ğŸ’¡ è¯¥é¡¹ç›®å¯èƒ½ä¸æ˜¯ç”± axum-app-create ç”Ÿæˆçš„ / \
                 This project may not have been generated by axum-app-create",
                metadata_path.display()
            )));
        }

        let content = std::fs::read_to_string(&metadata_path)?;
        let metadata: GenerationMetadata = serde_json::from_str(&content).map_err(|e| {
            CliError::Config(format!(
                "âŒ å…ƒæ•°æ®æ–‡ä»¶æ ¼å¼æ— æ•ˆ / Invalid metadata file format: {}\n   {}",
                metadata_path.display(),
                e
            ))
        })?;

        Ok(metadata)
    }

    /// Update metadata after an update operation
    pub fn update(
        project_dir: &Path,
        file_checksums: HashMap<String, String>,
    ) -> Result<()> {
        let mut metadata = Self::read(project_dir)?;
        metadata.version = env!("CARGO_PKG_VERSION").to_string();
        metadata.generated_at = chrono::Utc::now().to_rfc3339();
        metadata.file_checksums = file_checksums;

        let json = serde_json::to_string_pretty(&metadata).map_err(|e| {
            CliError::Generation(format!(
                "âŒ å…ƒæ•°æ®åºåˆ—åŒ–å¤±è´¥ / Metadata serialization failed: {}",
                e
            ))
        })?;

        let metadata_path = project_dir.join(METADATA_FILE);
        std::fs::write(&metadata_path, &json)?;

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    fn sample_config() -> ProjectConfig {
        ProjectConfig::default()
    }

    #[test]
    fn test_create_and_read_metadata() {
        let temp = TempDir::new().unwrap();
        let mut checksums = HashMap::new();
        checksums.insert("Cargo.toml".to_string(), "abc123".to_string());

        MetadataManager::create(temp.path(), &sample_config(), checksums.clone()).unwrap();

        let metadata = MetadataManager::read(temp.path()).unwrap();
        assert_eq!(metadata.file_checksums, checksums);
        assert_eq!(metadata.config.project_name, "my-axum-app");
    }

    #[test]
    fn test_read_nonexistent_metadata() {
        let temp = TempDir::new().unwrap();
        let result = MetadataManager::read(temp.path());
        assert!(result.is_err());
    }

    #[test]
    fn test_update_metadata() {
        let temp = TempDir::new().unwrap();
        let mut checksums = HashMap::new();
        checksums.insert("Cargo.toml".to_string(), "abc123".to_string());

        MetadataManager::create(temp.path(), &sample_config(), checksums).unwrap();

        let mut new_checksums = HashMap::new();
        new_checksums.insert("Cargo.toml".to_string(), "def456".to_string());
        new_checksums.insert("src/main.rs".to_string(), "ghi789".to_string());

        MetadataManager::update(temp.path(), new_checksums.clone()).unwrap();

        let metadata = MetadataManager::read(temp.path()).unwrap();
        assert_eq!(metadata.file_checksums, new_checksums);
    }
}

#[cfg(test)]
mod proptests {
    use super::*;
    use proptest::prelude::*;
    use proptest::collection::hash_map;

    fn arb_metadata() -> impl Strategy<Value = GenerationMetadata> {
        (
            "[0-9]{1,2}\\.[0-9]{1,2}\\.[0-9]{1,2}",
            "[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z",
            "[a-z][a-z0-9-]{0,15}",
            prop::bool::ANY,
            prop::bool::ANY,
            hash_map("[a-z/._]{1,20}", "[a-f0-9]{64}", 0..10),
        )
            .prop_map(
                |(version, generated_at, project_name, auth, ci, file_checksums)| {
                    let mut config = ProjectConfig::default();
                    config.project_name = project_name;
                    config.features.authentication = auth;
                    config.ci = ci;
                    GenerationMetadata {
                        version,
                        generated_at,
                        config,
                        file_checksums,
                    }
                },
            )
    }

    proptest! {
        #![proptest_config(ProptestConfig::with_cases(100))]

        /// Property 9: Metadata serialization round-trip
        /// For any valid GenerationMetadata, serializing to JSON and deserializing back
        /// should produce an equivalent struct.
        /// Feature: v030-template-and-update, Property 9: Metadata serialization round-trip
        /// **Validates: Requirements 4.2, 5.1, 5.2**
        #[test]
        fn prop_metadata_serialization_roundtrip(metadata in arb_metadata()) {
            let json = serde_json::to_string_pretty(&metadata).unwrap();
            let deserialized: GenerationMetadata = serde_json::from_str(&json).unwrap();
            prop_assert_eq!(metadata, deserialized);
        }
    }
}
