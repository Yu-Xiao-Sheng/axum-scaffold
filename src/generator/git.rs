// Git initialization
//
// This module handles git repository initialization.

use crate::error::{CliError, Result};
use git2::{Repository, Signature};
use std::path::Path;

/// Initialize a git repository in the project directory
///
/// This function:
/// - Runs `git init` to create the repository
/// - Creates a .gitignore file with standard Rust patterns
/// - Stages all files
/// - Creates an initial commit
///
/// # Arguments
/// * `project_dir` - Path to the project directory
///
/// # Returns
/// * `Ok(())` if git initialization succeeded
/// * `Err(CliError)` if git initialization failed
pub fn init_git_repo(project_dir: &Path) -> Result<()> {
    // Initialize repository
    let repo = match Repository::init(project_dir) {
        Ok(r) => r,
        Err(e) => {
            return Err(CliError::Git(format!(
                "Failed to initialize git repository: {}",
                e
            )))
        }
    };

    // Create .gitignore
    let gitignore_path = project_dir.join(".gitignore");
    let gitignore_content = get_gitignore_content();
    std::fs::write(&gitignore_path, gitignore_content)?;

    // Add all files to index
    let mut index = match repo.index() {
        Ok(i) => i,
        Err(e) => {
            return Err(CliError::Git(format!(
                "Failed to get git index: {}",
                e
            )))
        }
    };

    match index.add_all(["*"], git2::IndexAddOption::DEFAULT, None) {
        Ok(_) => {}
        Err(e) => {
            return Err(CliError::Git(format!(
                "Failed to add files to git index: {}",
                e
            )))
        }
    }

    if let Err(e) = index.write() {
        return Err(CliError::Git(format!(
            "Failed to write git index: {}",
            e
        )));
    }

    // Create initial commit
    let tree_id = match index.write_tree() {
        Ok(id) => id,
        Err(e) => {
            return Err(CliError::Git(format!(
                "Failed to write git tree: {}",
                e
            )))
        }
    };

    let tree = match repo.find_tree(tree_id) {
        Ok(t) => t,
        Err(e) => {
            return Err(CliError::Git(format!(
                "Failed to find git tree: {}",
                e
            )))
        }
    };

    // Create signature for commit
    let sig = match Signature::now("create-axum-app", "generator@create-axum-app") {
        Ok(s) => s,
        Err(e) => {
            return Err(CliError::Git(format!(
                "Failed to create git signature: {}",
                e
            )))
        }
    };

    // Create initial commit with no parents
    match repo.commit(
        Some("HEAD"),
        &sig,
        &sig,
        "Initial project generated by create-axum-app",
        &tree,
        &[], // No parents for initial commit
    ) {
        Ok(_) => {}
        Err(e) => {
            return Err(CliError::Git(format!(
                "Failed to create initial commit: {}",
                e
            )))
        }
    };

    Ok(())
}

/// Get the .gitignore content for Rust projects
fn get_gitignore_content() -> &'static str {
    r###"# Rust
/target/
**/*.rs.bk
Cargo.lock

# Environment
.env
.env.local
.env.*.local

# IDE
.idea/
.vscode/
*.swp
*.swo
*.swn

# OS
.DS_Store
Thumbs.db

# Logs
*.log

# Database
*.db
*.sqlite
*.sqlite3
"###
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_git_initialization() {
        let temp_dir = TempDir::new().unwrap();
        let project_dir = temp_dir.path().join("test-project");

        // Create project directory
        std::fs::create_dir_all(&project_dir).unwrap();

        // Initialize git repo
        let result = init_git_repo(&project_dir);

        // Check if it succeeded
        assert!(result.is_ok(), "Git initialization failed: {:?}", result.err());

        // Verify .gitignore was created
        assert!(project_dir.join(".gitignore").exists());

        // Verify .git directory exists
        assert!(project_dir.join(".git").exists());
    }

    #[test]
    fn test_gitignore_content() {
        let content = get_gitignore_content();
        assert!(content.contains("/target/"));
        assert!(content.contains(".env"));
        assert!(content.contains("Cargo.lock"));
        assert!(content.contains(".DS_Store"));
    }
}
